{
    "collab_server" : "",
    "contents" : "library(shiny)\nlibrary(DT)\n\n\n\nshinyServer(function(input, output, session) {\n  \n  observe({\n    # store the parsed query string \n    query <- parseQueryString(session$clientData$url_search)\n    output$urlText <- renderText({\n      paste(sep = \"\",\n            \"protocol: \", session$clientData$url_protocol, \"\\n\",\n            \"hostname: \", session$clientData$url_hostname, \"\\n\",\n            \"pathname: \", session$clientData$url_pathname, \"\\n\",\n            \"port: \",     session$clientData$url_port,     \"\\n\",\n            \"search: \",   session$clientData$url_search,   \"\\n\"\n      )\n    })\n    \n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n\t  username <- query$user\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    username <- \"default\"\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n\n  \n  # create a reactiveValues object with no values\n  # store values that can be updated in multiple places: \n  values <- reactiveValues() \n\n  allOrigDataSets_url <- paste0(\"http://fangorn.colby.edu/disco2/users/alloriginal.php?user=\",username)\n  allDataSets_url <- paste0(\"http://fangorn.colby.edu/disco2/users/alldatasets.php?user=\",username)\n  allPcaDataSets_url <- paste0(\"http://fangorn.colby.edu/disco2/users/allpcadatasets.php?user=\",username)\n  allSavedFiles_url <- paste0(\"http://fangorn.colby.edu/disco2/users/allanalysis.php?user=\",username)\n  \n\t  \n  tester <- readLines( allOrigDataSets_url)\n  allOrigDataSets = \"None\"\n\n  if( nchar(tester) > 1 ) {\n  df <- read.csv( allOrigDataSets_url, header=FALSE, stringsAsFactors = FALSE )\n  allOrigDataSets <- c(c(\"None\"), as.vector(unlist(df[\"V1\"])))\n  }\n  \n  tester <- readLines( allDataSets_url)\n  allDataSets = \"None\"\n\n\tif( nchar(tester) > 1 ) {\n  df <- read.csv( allDataSets_url, header=FALSE, stringsAsFactors = FALSE )\n  allDataSets <- c(\"None\")\n  files <- as.vector(unlist(df[\"V1\"]))\n  for(name in files){\n    allDataSets = c(allDataSets,substr(name,1,nchar(name)-4))\n  }\n  }\n  \n  tester <- readLines( allPcaDataSets_url)\n  allPcaDataSets = \"None\"\n\n  if( nchar(tester) > 1 ) {\n  df <- read.csv( allPcaDataSets_url, header=FALSE, stringsAsFactors = FALSE )\n  allPcaDataSets <- c(\"None\")\n  files <- as.vector(unlist(df[\"V1\"]))\n  for(name in files){\n    allPcaDataSets = c(allPcaDataSets,substr(name,1,nchar(name)-4))\n  }\n  }\n  \n  \n  tester <- readLines( allSavedFiles_url)\n\tallSavedFiles = \"None\"\n  if( nchar(tester)  > 1 ) {\n  df <- read.csv( allSavedFiles_url, header=FALSE, stringsAsFactors = FALSE )\n  allSavedFiles <- c(\"None\")\n  files <- as.vector(unlist(df[\"V1\"])) \n  for(name in files){\n    allSavedFiles = c(allSavedFiles,substr(name,1,nchar(name)-7))\n  }\n  }\n\n  \n  \n  \n  ################ Plot Data ################\n  \n  # reset input settings back to defaults when the data set used for simple plotting is changed\n  observeEvent(input$dataset_plot,{\n    updateSelectInput(session, \"plotX\", choices=headers_plot())\n    updateSelectInput(session, \"plotY\", choices=headers_plot(), selected=headers_plot()[2])\n    updateCheckboxInput(session, \"eckert\", value=FALSE)\n  })\n  \n  # update the list of select options for input$dataset_plot\n  observe({\n    updateSelectInput(session, \"dataset_plot\", choices=allDataSets,selected=\"None\")\n  })\n  \n  \n  \n  # return the original dataset name for a selected input$dataset_plot\n  # e.g. \"AustraliaCoast_pca_201707061322\" returns \"AustraliaCoast\"\n  #\"poker_game_pca_201707061322\" returns \"poker_game\"\n  #\"AustraliaCoast\" returns \"AustraliaCoast\"\n  origDataset_plot <- reactive({ \n    # if input$dataset_kmc itself is an original data set\n    if(input$dataset_plot %in% allOrigDataSets){\n      return (input$dataset_plot)\n    }\n    \n    # if input$dataset_plot is an PCA data set, need to extract the name of its original data set \n    else{\n      #split the input string by \"_\" and convert to a vector\n      splited = unlist(strsplit(input$dataset_plot, \"_\")) \n      \n      # remove \"pca\" and time substrings from the vector\n      name = head(splited,-2) \n      \n      # in case the dataset name contains \"_\" and has been seperated \n      if(length(name) > 1){\n        name = paste(name, collapse = \"_\")\n      }\n      \n      \n      return(name)\n    }\n    \n  })\n  \n  \n  # read data for simple plotting\n  # origDataset_plot() indicates the subdirectory that contains the data set,\n  # input$dataset_plot indicates the data set name \n  data_plot <- reactive({\n    if(input$dataset_plot!=\"None\"){ \n\n      data <- read.csv(paste(userDir,\"/\",origDataset_plot(),\"/dataset/\",input$dataset_plot,\".csv\",\n                     sep=\"\"))\n      origData <- read.csv(paste(userDir,\"/\",origDataset_plot(),\"/dataset/\",origDataset_plot(),\".csv\",\n                                 sep=\"\"))\n      \n      if(input$dataset_plot == origDataset_plot()){\n        return(data)\n      }\n      else{\n        return(cbind(data, origData))\n      }\n    }\n  })\n  \n  \n  \n  # return a vector of original data headers \n  orig_headers_plot <- reactive({\n    if(input$dataset_plot!=\"None\"){\n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n      \n      # read the type file\n      typeFile = read.csv(paste(userDir,\"/\",origDataset_plot(),\"/\",origDataset_plot(),\n                                \"_type.csv\", sep=\"\"))\n      \n      numericHeaders <- vector(length=0)\n      for(i in 1:length(names(typeFile))) {\n        if(typeFile[1,i]==\"number\"){\n          numericHeaders <- append(numericHeaders,names(typeFile)[i])\n        }\n      }\n      return(numericHeaders)\n    }\n    return(NULL)\n  })\n  \n  # return a list of numeric headers of the data set used for simple plotting\n  headers_plot <- reactive({\n    if(input$dataset_plot!=\"None\"){\n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n      \n      # if the selected data set is not a pca dataset, read the type file\n      if(input$dataset_plot %in% allOrigDataSets){\n       \n        return(orig_headers_plot())\n      }\n      \n      # if the selected data set is a pca data set \n      else{\n        dataFile = read.csv(paste(userDir,\"/\",origDataset_plot(),\"/dataset/\",input$dataset_plot,\n                                  \".csv\", sep=\"\"))\n        pcaDims <- names(dataFile)\n        \n        return(c(pcaDims, orig_headers_plot()))\n      }\n      \n      \n    }\n    return(NULL) #if no dataset has not been selected, return NULL\n  })\n  \n  output$simple_plot_fn <- renderPrint({\n    if(input$dataset_plot!=\"None\"){\n      h4(input$dataset_plot,align = \"center\")\n    }\n  })\n  \n  output$simple_plot <- renderPlot({\n    if(input$plotX %in% headers_plot()==FALSE || \n       input$plotY %in% headers_plot()==FALSE){\n      return()\n    }\n    if(!input$eckert){\n      plot( data_plot()[, input$plotX], data_plot()[, input$plotY],\n          xlab = input$plotX, ylab = input$plotY)\n    }\n    else{\n      # grab longitude and latitude\n      a <- data_plot()[, input$plotX]\n      \n      b <- data_plot()[, input$plotY]\n      \n      # convert Longitude from -180 to 180 to -4PI to 4PI\n      rangeA <- range(a)\n      \n      print(rangeA)\n      \n      rangeB <- range(b)\n      \n      print(rangeB)\n      \n      centerline <- mean(rangeA)\n      \n      print(centerline)\n      \n      y <- b * 4.0 * pi / 180.0\n      \n      tmp <- b / 90.0\n      \n      x <- 2 * (1  + sqrt(1 - tmp*tmp)) * (a - centerline) * pi / 180.0\n      \n      print(x)\n      print(y)\n      \n      plot(x, y)\n      \n      #readline(prompt=\"Enter to continue\")\n      \n      #plot(a, b)\n      \n    }\n  })\n  \n  output$simple_plot_pts <- renderText({\n    xy_str <- function(e) {\n      if(is.null(e)) return(\"NULL\\n\")\n      paste0(input$plotX, \" = \", round(e$x, 1), \"  \",\n             input$plotY, \" = \", round(e$y, 1), \"\\n\")\n    }\n    paste(\"Hover: \", xy_str(input$plot_hover))\n  })\n  \n  \n  \n  ################# K-means Clustering #################\n  \n  # add a list of data set choices to \"dataset_km\" selectInput \n  observe({\n    updateSelectInput(session, \"dataset_kmc\", choices=allDataSets,selected=\"None\")\n  })\n  \n  # reset input settings back to defaults when the data set used for kmeans clustering is changed\n  observeEvent(input$dataset_kmc,{\n    updateSelectInput(session, \"plotX_kmc\", choices=headers_kmc())\n    updateSelectInput(session, \"plotY_kmc\", choices=headers_kmc(), selected=headers_kmc()[2])\n    updateSelectInput(session, \"dims\", choices=headers_kmc()) \n    updateNumericInput(session, \"clusters\", value=3) \n    updateNumericInput(session, \"iter\", value=10) \n    \n    values$kmeansData <- NULL\n    values$results_kmc <- NULL\n  })\n  \n  # reset inputs when the reset button is clicked\n  observeEvent(input$reset_kmc,{\n    updateSelectInput(session, \"plotX_kmc\", choices=headers_kmc())\n    updateSelectInput(session, \"plotY_kmc\", choices=headers_kmc(), selected=headers_kmc()[2])\n    updateSelectInput(session, \"dims\", choices=headers_kmc()) \n    updateNumericInput(session, \"clusters\", value=3) \n    updateNumericInput(session, \"iter\", value=10) \n  })\n  \n  # return the original dataset name for a selected input$dataset_kmc\n  # e.g. \"AustraliaCoast_pca_201707061322\" returns \"AustraliaCoast\"\n  #\"poker_game_pca_201707061322\" returns \"poker_game\"\n  #\"AustraliaCoast\" returns \"AustraliaCoast\"\n  origDataset_kmc <- reactive({ \n    # if input$dataset_kmc itself is an original data set\n    if(input$dataset_kmc %in% allOrigDataSets){\n      return (input$dataset_kmc)\n    }\n    \n    # if input$dataset_kmc is an PCA data set, need to extract the name of its original data set \n    else{\n      #split the input string by \"_\" and convert to a vector\n      splited = unlist(strsplit(input$dataset_kmc, \"_\")) \n      \n      # remove \"pca\" and time substrings from the vector\n      name = head(splited,-2) \n      \n      # in case the dataset name contains \"_\" and has been seperated \n      if(length(name) > 1){\n        name = paste(name, collapse = \"_\")\n      }\n\n      \n      return(name)\n    }\n    \n  })\n  \n\n  # read data for k-means clustering \n  # origDataset_kmc() indicates the subdirectory that contains the data set,\n  # input$dataset_kmc indicates the data set name \n  data_kmc <- reactive({\n    if(input$dataset_kmc!=\"None\"){ \n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n\n      read.csv(paste(userDir,\"/\",origDataset_kmc(),\"/dataset/\",input$dataset_kmc,\".csv\",\n                     sep=\"\"))\n      #read.csv(\"http://cs.colby.edu/maxwell/iris_all.csv\")\n    }\n  })\n  \n  # return a list of numeric headers of the data set used for k-means clustering \n  headers_kmc <- reactive({\n    if(input$dataset_kmc!=\"None\"){\n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n      \n      # if the selected data set is not a pca dataset, read the type file\n      if(input$dataset_kmc %in% allOrigDataSets){\n      \n        # read the type file\n        typeFile = read.csv(paste(userDir,\"/\",origDataset_kmc(),\"/\",origDataset_kmc(),\n                                  \"_type.csv\", sep=\"\"))\n        \n        numericHeaders <- vector(length=0)\n        for(i in 1:length(names(typeFile))) {\n          if(typeFile[1,i]==\"number\"){\n            numericHeaders <- append(numericHeaders,names(typeFile)[i])\n          }\n        }\n        return(numericHeaders)\n      }\n      \n      # if the selected data set is a pca data set \n      else{\n        dataFile = read.csv(paste(userDir,\"/\",origDataset_kmc(),\"/dataset/\",input$dataset_kmc,\n                                  \".csv\", sep=\"\"))\n        return(names(dataFile))\n      }\n      \n  \n    }\n    else{    #if no dataset has not been selected, return an empty vector\n      return(vector(length=0))\n    }\n  })\n\n  \n  output$kmc_fn <- renderPrint({\n    if(input$dataset_kmc!=\"None\"){\n      h4(input$dataset_kmc,align = \"center\")\n    }\n  })\n  \n  cluster_names <- function(centers){\n    dims_names <- colnames(centers)\n    K <- nrow(centers) # number of clusters\n    \n    return_names <- vector(length = K)\n    \n    # Create a K by K matrix M, initialize it to all -1 values\n    M <- matrix(-1, K, K)\n    \n    dims_sd <- apply(centers, 2, sd) # sd of each dimension\n    \n    # compare each pair of cluster means  \n    for(i in 1:K){\n      for(j in 1:K){\n        if(i != j){\n          # d is the largest meaningful difference between mean i and mean j \n          d <- -1\n          for(k in 1:length(dims_names)){\n            diff <- abs(centers[i, k] - centers[j, k]) / dims_sd[k]\n            \n            if(diff >= d){\n              d <- diff \n              M[i, j] <- k\n            }\n          }\n          \n        }\n      }\n    }\n    \n    A <- vector(length = K)\n    B <- vector(length = K)\n    C <- vector(length = K)\n    \n    # adjectives for dimensions (low, average, high)\n    A_adj <- vector(length = K)\n    B_adj <- vector(length = K)\n    C_adj <- vector(length = K)\n    \n    for(i in 1:nrow(M)){\n      row <- table(M[i, ]) \n      sorted_dims <- names(sort(row, decreasing = TRUE))\n      sorted_dims <- sorted_dims[sorted_dims >= 1]\n      \n      A[i] <- sorted_dims[1] # the most common dimension value in row i that is >= 1\n      \n      if(length(sorted_dims) > 1){\n        B[i] <- sorted_dims[2] # the second most common dimension value in row i that is >= 1\n        \n        if(length(sorted_dims) > 2){\n          C[i] <- sorted_dims[3] # the third most common dimension value in row i that is >= 1\n        }\n        else{\n          C[i] <- -1\n        }\n      }\n      else{\n        B[i] <- -1\n      }\n    \n      \n      \n      col <- as.numeric(A[i])\n      A_data_min <- min(centers[,col])\n      A_data_max <- max(centers[,col])\n      A_data_range <- A_data_max - A_data_min\n      one_third <- A_data_min + A_data_range*1/3\n      two_third <- A_data_min + A_data_range*2/3\n      if(centers[i, col] <= one_third){\n        A_adj[i] <- \"low\" #‘low’ if u_A_i is in the bottom third of the values of column A_i\n      }\n      else if( one_third < centers[i, col] && centers[i, col] <= two_third){\n        A_adj[i] <- \"avg\" # “avg’ if u_A is in the middle third of the values of column A_i\n      }\n      else{\n        A_adj[i] <- \"high\" # “high” if u_A is in the top third of the values of column A_i\n      }\n      \n      if(B[i] >= 1){\n        col <- as.numeric(B[i])\n        B_data_min <- min(centers[, col])\n        B_data_max <- max(centers[, col])\n        B_data_range <- B_data_max - B_data_min\n        one_third <- B_data_min + B_data_range*1/3\n        two_third <- B_data_min + B_data_range*2/3\n        if(centers[i, col] <= one_third){\n          B_adj[i] <- \"low\"\n        }\n        else if( one_third < centers[i, col] && centers[i, col] <= two_third){\n          B_adj[i] <- \"avg\"\n        }\n        else{\n          B_adj[i] <- \"high\"\n        }\n      }\n      \n      if(C[i] >= 1){\n        col <- as.numeric(C[i])\n        C_data_min <- min(centers[, col])\n        C_data_max <- max(centers[, col])\n        C_data_range <- C_data_max - C_data_min\n        one_third <- C_data_min + C_data_range*1/3\n        two_third <- C_data_min + C_data_range*2/3\n        if(centers[i, col] <= one_third){\n          C_adj[i] <- \"low\"\n        }\n        else if( one_third < centers[i, col] && centers[i, col] <= two_third){\n          C_adj[i] <- \"avg\"\n        }\n        else{\n          C_adj[i] <- \"high\"\n        }\n      }\n      \n      title <- paste0(A_adj[i] , \"_\",dims_names[as.numeric(A[i])])\n      \n  \n      \n      if(B[i] >= 1){\n        title <- paste0(title , \"_\", B_adj[i], \"_\", dims_names[as.numeric(B[i])])\n      }\n      \n      if(C[i] >= 1){\n        title <- paste0(title , \"_\", C_adj[i], \"_\", dims_names[as.numeric(C[i])])\n      }\n      return_names[i] <- title\n    }\n    \n    # print(M)\n    # print(A)\n    # print(B)\n    # print(C)\n    return(return_names)\n    \n  } \n  \n  \n  \n\n  # plot k-means clustering output\n  observeEvent(input$ok_kmc,{\n    if(is.null(input$dims)|| nchar(input$dims) < 1){\n      return()\n    }\n    \n    values$kmeansData <- data_kmc()[, input$dims]\n    values$results_kmc <- kmeans(values$kmeansData, input$clusters, input$iter)\n    \n    \n    palette(\"default\") # use default palette\n    \n    output$kmeans <- renderPlot({\n      \n      # return if current input$kmeansPlotX or input$kmeansPlotY is not in headers_kmc()\n      # sometimes values for these two inputs do not get updated immediately when data set \n      # is changed\n      if(input$plotX_kmc %in% headers_kmc()==FALSE || \n         input$plotY_kmc %in% headers_kmc()==FALSE){\n        return()\n      }\n      \n      par(mar = c(5.1, 4.1, 0, 1)) # specify margins\n  \n      xvar = data_kmc()[,input$plotX_kmc]\n      yvar = data_kmc()[,input$plotY_kmc]\n      \n      \n      plot(xvar, yvar, col = values$results_kmc$cluster, xlab=input$plotX_kmc,\n           ylab=input$plotY_kmc, pch = 20, cex = 2)\n      #points(kmeansClusters()$centers, pch = 4, cex = 4, lwd = 4)\n      \n      #ggplot(data_kmc(), aes(input$plotX_kmc, input$plotY_kmc, color = values$results_kmc$cluster)) + geom_point()\n    })\n    \n    \n    # format a table for displaying cluster means and sizes\n    if(is.null(values$results_kmc)){\n      return()\n    }\n    \n    centers = round(values$results_kmc$center,4)\n    \n    cluster_names <- cluster_names(centers)\n    \n    if(is.null(colnames(centers))){\n      colnames(centers) <- isolate(input$dims)\n    }\n    table <- cbind(cluster_names, centers)\n    table <- cbind(table, values$results_kmc$size)\n    colnames(table) <- c(\"Cluster Name\", colnames(centers), \"Cluster Size\")\n    \n    # create a palette for kmeans_table, since green in palette() is \"green3\", replace it with \"green\"\n    mypalette <- palette()\n    mypalette[3] <- \"green\" #\"green3\" is not defined in styleEqual\n    \n\n    kmeans_table <- datatable(table,\n                              caption='Table 1: Cluster Mean and Size.',\n                              options = list(paging=FALSE, searching = FALSE)) %>% formatStyle(\n      column = 0,\n      color = styleEqual(1:isolate(input$clusters),  mypalette[1: isolate(input$clusters)])\n    )\n    \n    output$kmeans_centers <- DT::renderDataTable(kmeans_table)\n    \n\n  })\n  \n  \n  \n    \n  # save an k-means clustering analysis \n  observeEvent(input$save_kmc,{\n    \n    results = values$results_kmc\n \n    if(!is.null(results)){\n      showModal(nameKmcModal())\n    }\n  })\n  \n  # create a modal(dialog box) to allow the user to enter a customized name\n  nameKmcModal <- function(failed = FALSE) {\n    modalDialog(\n      textInput(\"name_kmc\", paste0(\"Name Your Analysis: \",input$dataset_kmc,\n                \"_cluster_\"), placeholder = 'Type in a name or use current time as name '),\n      span(\"The following symbols are not allowed: \"),\n      tags$br(),\n      span(\"\\ / : * ? | < > _ space\"),\n      if (failed)\n        div(tags$b(\"The name doesn't have the right format or it already exists.\", style = \"color: red;\")),\n      \n      footer = tagList(\n        modalButton(\"Cancel\"),\n        actionButton(\"name_kmc_cancel\", \"Use Current Time as Name\"),\n        actionButton(\"name_kmc_ok\", \"OK\")\n      ) \n    )\n  }\n  \n  # name the analysis with user input name\n  # only allow the user to name the last part of the filename \n  # \"AustraliaCoast_cluster_[named by user]\"\n  observeEvent(input$name_kmc_ok, {\n    # Check if user input is not empty\n    if (!is.null(input$name_kmc) && nzchar(input$name_kmc)) {\n      # check if user input is valid\n      checked <- gsub(\"[\\\\<>:|?*_/[:space:]]\", \".\" ,input$name_kmc)\n      if(checked != input$name_kmc){\n        print(\"not matched\")\n        showModal(nameKmcModal(failed = TRUE))\n        return()\n      }\n      \n      # check if filename already exists \n      fn <- paste0(input$dataset_kmc,\"_cluster_\",input$name_kmc)\n      \n      if(fn %in% allSavedFiles){\n        showModal(nameKmcModal(failed = TRUE))\n      }\n      else{\n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n       \n        print(paste0(userDir,\"/\",origDataset_kmc(),\"/analysis/\",input$dataset_kmc,\n                     \"_cluster_\",input$name_kmc,\"_id.csv\")) \n        \n        results = values$results_kmc\n        \n        # save ids\n        # write results()$cluster to a csv file\n        idFile = paste0(userDir,\"/\",origDataset_kmc(),\"/analysis/\",input$dataset_kmc,\n                       \"_cluster_\",input$name_kmc,\"_id.csv\")\n        write.table(results$cluster, idFile, sep=\",\", row.names=FALSE)\n\n        # save means\n        meanFile = paste(userDir,\"/\",origDataset_kmc(),\"/analysis/\",input$dataset_kmc,\n                         \"_cluster_\",input$name_kmc,\"_mean.csv\", sep=\"\")\n        table <- cbind(results$center, results$size)\n        colnames(table) <- c(colnames(results$center), \"Cluster Size\")\n\n        write.table(table, meanFile, sep=\",\", row.names=FALSE)\n\n        # add this filename to allSavedFiles and update relevent selectInputs\n        name <- paste0(input$dataset_kmc,\"_cluster_\",input$name_kmc)\n        allSavedFiles <- c(allSavedFiles, name )\n        updateSelectInput(session, \"dataset_plot\", choices=allSavedFiles)\n        updateSelectInput(session, \"fn_kmc\", choices=allSavedFiles)\n        \n        removeModal()\n\n        # show a success message\n        showModal(modalDialog( title = \"K-means Clustering Analysis\",\n                               paste0(\"This analysis has been saved as \", name),\n                               footer = modalButton(\"Ok\")\n                               ))\n      \n      }\n    }\n  })\n  \n  # name the kmc analysis with current time \n  # \"AustraliaCoast_cluster_YYYYMMDDHHMM\"\n  observeEvent(input$name_kmc_cancel, {\n    removeModal() \n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n    \n    # generate a string of current time in the format of YYYYMMDDHHMM\n    # e.g. 201707061152\n    time <- format(Sys.time(), \"%Y%m%d%H%M\")\n    print(paste0(userDir,\"/\",origDataset_kmc(),\"/analysis/\",input$dataset_kmc,\n                 \"_cluster_\",time,\"_id.csv\"))\n    \n    results = values$results_kmc\n    \n    # save ids\n    # write results()$cluster to a csv file\n    idFile = paste0(userDir,\"/\",origDataset_kmc(),\"/analysis/\",input$dataset_kmc,\n                    \"_cluster_\",time,\"_id.csv\")\n    write.table(results$cluster, idFile, sep=\",\", row.names=FALSE)\n    \n    # save means\n    meanFile = paste(userDir,\"/\",origDataset_kmc(),\"/analysis/\",input$dataset_kmc,\n                     \"_cluster_\",time,\"_mean.csv\", sep=\"\")\n    table <- cbind(results$center, results$size)\n    colnames(table) <- c(colnames(results$center), \"Cluster Size\")\n    \n    write.table(table, meanFile, sep=\",\", row.names=FALSE)\n    \n    # add this filename to allSavedFiles and update relevent selectInputs\n    name <- paste0(input$dataset_kmc,\"_cluster_\",time)\n    allSavedFiles <- c(allSavedFiles, name )\n    updateSelectInput(session, \"dataset_plot\", choices=allSavedFiles)\n    updateSelectInput(session, \"fn_kmc\", choices=allSavedFiles)\n    \n    \n    # show a success message\n    showModal(modalDialog( title = \"K-means Clustering Analysis\",\n                           paste0(\"This analysis has been saved as \", name),\n                           footer = modalButton(\"Ok\")\n    ))\n    \n    \n  })\n\n  \n  ################ Principle Component Analysis ########\n  \n  # add a list of dataset options to input$dataset_pca\n  observe({\n    updateSelectInput(session, \"dataset_pca\", choices=allOrigDataSets,selected=\"None\")\n  })\n  \n  # reset settings and reactive values related to pca back to defaults when the data set is changed\n  observeEvent(input$dataset_pca,{\n    updateSelectInput(session, \"dims_pca\", choices=headers_pca()) \n    updateCheckboxInput(session, \"normalize\", value=TRUE)\n    values$pca_eigen_table  <- NULL      \n    values$pca_projected_data <- NULL\n    values$pca_results <- NULL\n  })\n  \n  # reset inputs when the reset button is clicked\n  observeEvent(input$reset_pca,{\n    updateSelectInput(session, \"dims_pca\", choices=headers_pca()) \n    updateCheckboxInput(session, \"normalize\", value=TRUE)\n  })\n  \n  # read data for pca\n  data_pca <- reactive({\n    if(input$dataset_pca!=\"None\"){ \n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n\n      read.csv(paste(userDir,\"/\",input$dataset_pca,\"/dataset/\",input$dataset_pca,\".csv\",\n                     sep=\"\"))\n      #read.csv(\"http://cs.colby.edu/maxwell/iris_all.csv\")\n    }\n    else{\n      return(NULL)\n    }\n  })\n  \n  \n  # return a list of numeric headers of the data set used for pca\n  headers_pca <- reactive({\n    if(input$dataset_pca!=\"None\"){\n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n\n      # read the type file\n      typeFile = read.csv(paste(userDir,\"/\",input$dataset_pca,\"/\",input$dataset_pca,\n                                \"_type.csv\", sep=\"\"))\n      \n      numericHeaders <- vector(length=0)\n      for(i in 1:length(names(typeFile))) {\n        if(typeFile[1,i]==\"number\"){\n          numericHeaders <- append(numericHeaders,names(typeFile)[i])\n        }\n      }\n      return(numericHeaders)\n    }\n    else{    #if no dataset has not been selected, return NULL\n      return(NULL)\n    }\n  })\n  \n  numeric_data_pca <- reactive({\n    if(!is.null(data_pca()) && !is.null(headers_pca())){\n      return(data_pca()[headers_pca()])\n    }\n    return(NULL)\n  })\n  \n  # return a list of min, max and range of the columns of the numeric data \n  data_summary_pca <- reactive({\n    if(!is.null(numeric_data_pca())){\n      min <- apply(numeric_data_pca(),2,min,na.rm=TRUE)\n      min <- as.vector(min) \n      max <- apply(numeric_data_pca(),2,max,na.rm=TRUE)\n      max <- as.vector(max)\n      range = max - min\n      mean <- apply(numeric_data_pca(),2,mean,na.rm=TRUE)\n      mean <- as.vector(mean)\n      \n      return(list(min=min, max=max, range=range, mean=mean))\n    }\n    return(NULL)\n  })\n  \n  # normalize a data frame\n  # subtract each column by its min, then divide it by its range\n  normalize <- function(data){\n    \n    result <- data # make a copy of the input data frame\n    min <- data_summary_pca()$min\n    range <- data_summary_pca()$range\n    \n    # operate on each column\n    for(i in 1:length(names(result))){\n      col <- names(result)[i]\n      result[,col] <- (result[,col] - min[i]) / range[i]\n    }\n    \n    return(result)\n  }\n  \n  \n  # return pca results\n  pca_results <- eventReactive(input$ok_pca,{\n    if(input$dataset_pca!=\"None\"){\n      if(!is.null(input$dims_pca) && nchar(input$dims_pca) > 0){\n          \n          if(input$normalize){\n            data = normalize(numeric_data_pca())\n          }\n          else{\n            data = numeric_data_pca()\n          }\n          data_subset <- na.omit(data[, input$dims_pca])\n          \n          pca_output <- prcomp(na.omit(data_subset), \n                               center = TRUE, scale. = FALSE, retx=TRUE)\n          return(pca_output)\n      \n      }\n      else{\n        return(NULL)\n      }\n    }\n    else{\n      return(NULL)\n    }\n  })\n  \n\n  # return a vector of eigenvalues\n  pca_eigenVals <- eventReactive(input$ok_pca,{\n    pca_results()$sdev^2\n  })\n  \n  # return a vector of cumulative proportions explanied by eigenvectors\n  pca_eigenVals_cum_props <- eventReactive(input$ok_pca,{\n    cumsum(pca_eigenVals()/sum(pca_eigenVals()))\n  })\n  \n  # return a summary table of eigenvalues and eigenvectors \n  pca_eigen_table <- eventReactive(input$ok_pca,{\n    if(!is.null(pca_results()) && dim(pca_results()$rotation)!=1){\n      # transpose and round pca_results()$rotation\n      eigVecs <- round(t(pca_results()$rotation),4)\n      eigVecs_names <- colnames(pca_results()$x)\n    \n      table <- cbind(round(pca_eigenVals(),4), round(pca_eigenVals_cum_props(),4))\n      table <- cbind(table, eigVecs) \n      table <- cbind(eigVecs_names, table)\n      \n      # add a row of original column means\n      means <- round(apply(numeric_data_pca(),2,mean)[input$dims_pca],4)\n      means <- as.vector(means)\n      means <- c(c(NA,NA,\"Mean\"), means)\n      table <- rbind(table, means)\n      \n      # add a row of original column sd\n      sd <- round(apply(numeric_data_pca(),2,sd)[input$dims_pca],4)\n      sd <- as.vector(sd)\n      sd <- c(c(NA,NA,\"SD\"), sd)\n      table <- rbind(table, sd)\n    \n      colnames(table) <- c(c(\"E-vec\", \"E-val\",\"Cumulative\"), colnames(eigVecs))\n      \n      return(table)\n    }\n    else{\n      return(NULL)\n    }\n  })\n  \n  # return a matrix of pca projected data\n  pca_projected_data <- eventReactive(input$ok_pca,{\n    if(!is.null(pca_results()) ){\n      return(pca_results()$x)\n    }\n    else{\n      return(NULL)\n    }\n  })\n  \n  output$pca_fn <- renderPrint({\n    if(input$dataset_pca!=\"None\"){\n      h4(input$dataset_pca,align = \"center\")\n    }\n  })\n  \n  # disply tables and graphs if input$ok_pca is clicked\n  observeEvent(input$ok_pca,{\n    \n    values$pca_eigen_table <- isolate(pca_eigen_table())\n    values$pca_projected_data <- isolate(pca_projected_data())\n    values$pca_results <- isolate(pca_results())\n    \n    output$pca_eig <- renderTable(values$pca_eigen_table, na=\"\", digits=4)   \n    \n\n    output$pca_table <- DT::renderDataTable(\n      round(values$pca_projected_data,4),caption = 'Projected PCA Data', options = list(searching = FALSE) \n    )\n    \n    output$pca_plots <-renderPlot({\n      x <- values$pca_results\n      if(is.null(x)){\n        return(NULL)\n      }\n      x.var <- x$sdev ^ 2\n      x.pvar <- x.var/sum(x.var)\n      print(\"proportions of variance:\")\n      print(x.pvar)\n\n      par(mfrow=c(2,2))\n      barplot(x.pvar,xlab=\"Principal Component\", ylab=\"Proportion of Variance Explained\", ylim=c(0,1))\n      plot(cumsum(x.pvar),xlab=\"Principal Component\", ylab=\"Cumulative Proportion of Variance Explained\", ylim=c(0,1))\n      par(mfrow=c(1,1))\n    })\n  })\n  \n  # save a PCA\n  observeEvent(input$save_pca,{\n  \n    if(!is.null(pca_projected_data())){\n      showModal(namePcaModal())\n    }\n  })\n  \n  # create a modal(dialog box) to allow the user to enter a customized name\n  namePcaModal <- function(failed = FALSE) {\n    modalDialog(\n      textInput(\"name_pca\", paste0(\"Name Your Analysis: \",input$dataset_pca,\n                                   \"_pca_\"), placeholder = 'Type in a name or use current time as name '),\n      span(\"The following symbols are not allowed: \"),\n      tags$br(),\n      span(\"\\ / : * ? | < > _ space\"),\n      if (failed)\n        div(tags$b(\"The name doesn't have the right format or it already exists.\", style = \"color: red;\")),\n      \n      footer = tagList(\n        modalButton(\"Cancel\"),\n        actionButton(\"name_pca_cancel\", \"Use Current Time as Name\"),\n        actionButton(\"name_pca_ok\", \"OK\")\n      ) \n    )\n  }\n  \n  # name the analysis with user input name\n  # only allow the user to name the last part of the filename \n  # \"AustraliaCoast_pca_[named by user]\"\n  observeEvent(input$name_pca_ok, {\n    # make sure user input is not empty\n    if (!is.null(input$name_pca) && nzchar(input$name_pca)) {\n      # check if user input is valid\n      checked <- gsub(\"[\\\\<>:|?*_/[:space:]]\", \".\" ,input$name_pca)\n      if(checked != input$name_pca){\n        showModal(namePcaModal(failed = TRUE))\n        return()\n      }\n      \n      # check if filename already exists \n      fn <- paste0(input$dataset_pca,\"_pca_\",input$name_pca)\n      \n      if(fn %in% allSavedFiles){\n        showModal(namePcaModal(failed = TRUE))\n      }\n      else{\n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n        \n        # save projected data\n        dataFile = paste(userDir,\"/\",input$dataset_pca,\"/dataset/\",input$dataset_pca,\n                         \"_pca_\",input$name_pca,\".csv\", sep=\"\")\n        write.table(pca_projected_data(), dataFile, sep=\",\", row.names=FALSE)\n        \n        # save eigenvalues, proportions, eigenvectors, means and sd of the original data\n        anlysFile = paste(userDir,\"/\",input$dataset_pca,\"/analysis/\",input$dataset_pca,\n                          \"_pca_\",input$name_pca, \"_anlys.csv\", sep=\"\")\n        \n        write.table(pca_eigen_table(), anlysFile, sep=\",\", row.names=FALSE)\n        \n        # add this pca dataset name to allDataSets and allPcaDataSets\n        # update the dropdown list for input$dataset_kmc\n        name <- paste0(input$dataset_pca,\"_pca_\",input$name_pca)\n        allDataSets <- c(allDataSets, name )\n        allPcaDataSets <- c(allPcaDataSets, name )\n        \n        updateSelectInput(session, \"dataset_kmc\", choices=allDataSets)\n        updateSelectInput(session, \"fn_pca\", choices=allPcaDataSets)\n        \n        removeModal()\n        \n        # show a success message\n        showModal(modalDialog( title = \"Principle Component Analysis\",\n                               paste0(\"This analysis has been saved as \", name, \".\"),\n                               footer = modalButton(\"Ok\")\n        ))\n        \n      }\n    }\n  })\n  \n  # name the kmc analysis with current time \n  # \"AustraliaCoast_cluster_YYYYMMDDHHMM\"\n  observeEvent(input$name_pca_cancel, {\n    removeModal() \n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n    \n    # generate a string of current time in the format of YYYYMMDDHHMM\n    # e.g. 201707061152\n    time <- format(Sys.time(), \"%Y%m%d%H%M\")\n    \n    # save projected data\n    dataFile = paste(userDir,\"/\",input$dataset_pca,\"/dataset/\",input$dataset_pca,\n                     \"_pca_\",time,\".csv\", sep=\"\")\n    write.table(pca_projected_data(), dataFile, sep=\",\", row.names=FALSE)\n    \n    # save eigenvalues, proportions, eigenvectors, means and sd of the original data\n    anlysFile = paste(userDir,\"/\",input$dataset_pca,\"/analysis/\",input$dataset_pca,\n                      \"_pca_\",time, \"_anlys.csv\", sep=\"\")\n    \n    write.table(pca_eigen_table(), anlysFile, sep=\",\", row.names=FALSE)\n    \n    # add this pca dataset name to allDataSets and allPcaDataSets\n    # update the dropdown list for input$dataset_kmc\n    name <- paste0(input$dataset_pca,\"_pca_\",time)\n    allDataSets <- c(allDataSets, name )\n    allPcaDataSets <- c(allPcaDataSets, name )\n    \n    updateSelectInput(session, \"dataset_kmc\", choices=allDataSets)\n    updateSelectInput(session, \"fn_pca\", choices=allPcaDataSets)\n    \n    removeModal()\n    \n    # show a success message\n    showModal(modalDialog( title = \"Principle Component Analysis\",\n                           paste0(\"This analysis has been saved as \", name,\".\"),\n                           footer = modalButton(\"Ok\")\n    ))\n    \n  })\n  \n\n  \n  \n  \n  ############# View Analysis #################\n  \n  # add a list of filename choices to \"filename\" selectInput on the \"View Analysis\" page\n  observe({\n    updateSelectInput(session, \"fn_kmc\", choices=allSavedFiles,selected=\"None\")\n    updateSelectInput(session, \"fn_pca\", choices=allPcaDataSets,selected=\"None\")\n  })\n  \n  # update select options for input$plotX_va and input$plotY_va if input$fn_kmc changes\n  observeEvent(input$fn_kmc,{\n    updateSelectInput(session, \"plotX_va\", choices=headers_view_kmc())\n    updateSelectInput(session, \"plotY_va\", choices=headers_view_kmc(), selected=headers_view_kmc()[2])\n  })\n  \n  # set input$fn_pca to \"None\" if input$fn_kmc is not \"None\n  observe({\n    if(input$fn_kmc!= \"None\"){\n      updateSelectInput(session, \"fn_pca\", selected=\"None\")\n    }\n  })\n  \n  # set input$fn_kmc to \"None\" if input$fn_pca is not \"None\n  observe({\n    if(input$fn_pca!= \"None\"){\n      updateSelectInput(session, \"fn_kmc\", selected=\"None\")\n    }\n  })\n  \n  # read data for viewing a previously saved analysis\n  data_view_kmc <- reactive({\n    if(!is.null(input$fn_kmc) && nchar(input$fn_kmc)>0 && input$fn_kmc!=\"None\"){ \n      dataset = strsplit(input$fn_kmc, \"_\")[[1]][[1]]\n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n      \n      read.csv(paste(userDir,\"/\",dataset,\"/dataset/\",dataset,\".csv\",\n                     sep=\"\"))\n      #read.csv(\"http://cs.colby.edu/maxwell/iris_all.csv\")\n    }\n    \n  })\n  \n  data_view_pca <- reactive({\n    if(!is.null(input$fn_pca) && nchar(input$fn_pca)>0 && input$fn_pca!=\"None\"){ \n      dataset = input$fn_pca\n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n\n\n      read.csv(paste(userDir,\"/\",dataset,\"/dataset/\",dataset,\".csv\",\n                     sep=\"\"))\n      #read.csv(\"http://cs.colby.edu/maxwell/iris_all.csv\")\n    }\n  })\n  \n  \n  # return a list of numeric headers of the data set used for viewing a previously saved analysis\n  headers_view_kmc <- reactive({\n    if(!is.null(input$fn_kmc) && nchar(input$fn_kmc)>0 && input$fn_kmc!=\"None\"){ \n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n\n      dataset = strsplit(input$fn_kmc, \"_\")[[1]][[1]]\n      typeFile = read.csv(paste(userDir,\"/\",dataset,\"/\",dataset,\n                                \"_type.csv\", sep=\"\"))\n      \n      numericHeaders <- vector(length=0)\n      for(i in 1:length(names(typeFile))) {\n        if(typeFile[1,i]==\"number\"){\n          numericHeaders <- append(numericHeaders,names(typeFile)[i])\n        }\n      }\n      return(numericHeaders)\n    }\n    else{ #if no dataset has not been selected, return NULL\n      return(NULL)\n    }\n  })\n\n  \n  # display filename of the selected analysis\n  output$viewSaved_fn <- renderPrint({\n    if(input$fn_kmc!=\"None\"){\n      h4(input$fn_kmc,align = \"center\")\n    }\n    else{\n      if(input$fn_pca!=\"None\"){\n        h4(input$fn_pca,align = \"center\")\n      }\n    }\n  })\n\n  observe({\n    if(input$fn_kmc!=\"None\"){ \n\n      # display a scatterplot of clustered data\n      output$viewSaved_kmc <- renderPlot({\n        \n        if(input$plotX_va %in% headers_view_kmc()==FALSE || \n           input$plotY_va %in% headers_view_kmc()==FALSE){\n          return()\n        }\n\n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n      \n        dataset = strsplit(input$fn_kmc, \"_\")[[1]][[1]]\n        idFile =  paste(userDir,\"/\",dataset,\"/analysis/\",input$fn_kmc,\"_id.csv\", sep=\"\")\n        cluster = unlist(read.csv(idFile))\n    \n        plot(data_view_kmc()[,input$plotX_va], data_view_kmc()[,input$plotY_va],\n             col = cluster, xlab=input$plotX_va,\n             ylab=input$plotY_va, pch = 20, cex = 2)\n      })\n      \n      \n      output$viewSaved_kmc_centers <- DT::renderDataTable({\n        if(input$fn_kmc == \"None\"){\n          return()\n        }\n        \n        dataset <- strsplit(input$fn_kmc, \"_\")[[1]][[1]]\n        meanFile <-  paste(userDir,\"/\",dataset,\"/analysis/\",input$fn_kmc,\"_mean.csv\", sep=\"\")\n        centers <- round(read.csv(meanFile),4)\n        numClusters <- nrow(centers)\n        \n        # create a palette for kmeans_table, since green in palette() is \"green3\", replace it with \"green\"\n        mypalette <- palette()\n        mypalette[3] <- \"green\" #\"green3\" is not defined in styleEqual\n        \n        kmeans_table <- datatable(centers,\n                                  caption='Table 1: Cluster Mean and Size.',\n                                  options = list(paging=FALSE, searching = FALSE)) %>% formatStyle(\n          column = 0,\n          color = styleEqual(1:isolate(numClusters),  mypalette[1: isolate(numClusters)])\n        )\n        return(kmeans_table)\n      })\n    }\n  })\n  \n  observe({\n    if(input$fn_pca!=\"None\"){ \n      \n  query <- parseQueryString(session$clientData$url_search)\n\tif(!is.null(query$user)) {\n    userDir <- paste0(\"http://fangorn.colby.edu/disco2/users/\",query$user)\n  }\n  else {\n    userDir <- \"http://fangorn.colby.edu/disco2/users/default\"\n  }\n\n      origDataset <- strsplit(input$fn_pca, \"_\")[[1]][[1]]\n      tableFile <- read.csv(paste0(userDir,\"/\",origDataset,\"/analysis/\",input$fn_pca,\"_anlys.csv\"))\n      \n      output$viewSaved_pca_eig <- renderTable(tableFile, na=\"\", digits=4)\n      \n      output$viewSaved_pca_plots <-renderPlot({\n        var <- as.vector(apply(tableFile[\"E.val\"],2,sqrt))\n        var <- head(var,-2) \n        pvar <- var/sum(var)\n        print(\"proportions of variance:\")\n        print(pvar)\n        \n        par(mfrow=c(2,2))\n        barplot(pvar,xlab=\"Principal Component\", ylab=\"Proportion of Variance Explained\", ylim=c(0,1))\n        plot(cumsum(pvar),xlab=\"Principal Component\", ylab=\"Cumulative Proportion of Variance Explained\", ylim=c(0,1))\n        par(mfrow=c(1,1))\n      })\n      \n      dataFile <- round(read.csv(paste0(userDir,\"/\",origDataset,\"/dataset/\",input$fn_pca,\".csv\")),4)\n      output$viewSaved_pca_table <- DT::renderDataTable(\n        dataFile,caption = 'Projected PCA Data', options = list(searching = FALSE,scrollX = TRUE) \n      )\n    }\n  })\n  })\n\n})\n",
    "created" : 1501341530714.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "817963427",
    "id" : "FBFB28A3",
    "lastKnownWriteTime" : 1501341514,
    "last_content_update" : 1501341514,
    "path" : "/Volumes/personal/jdong/rshiny/analysis/server.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}